# 多线程面试问题

## 1、并发编程的三个特征？

1. **原子性** : 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。`synchronized` 可以保证代码片段的原子性。
2. **可见性** ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。`volatile` 关键字可以保证共享变量的可见性。
3. **有序性** ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile` 关键字可以禁止指令进行重排序优化。

## 2、synchronized关键字

1. **Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。**
2. **Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。**
3. **Synchronized由什么样的缺陷?  Java Lock是怎么弥补这些缺陷的。**
4. **Synchronized和Lock的对比，和选择?**
5. **Synchronized在使用时有何注意事项?**
6. **Synchronized修饰的方法在抛出异常时,会释放锁吗?**
7. **多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?**
8. **Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?**
9. **我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?**
10. **什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?**
11. **不同的JDK中对Synchronized有何优化**

## 3、lock

## 4、volatile关键字

### 4.1、**volatile关键字的作用是什么?**

### 4.2、**volatile能保证原子性吗?**（**i++为什么不能保证原子性?**）

​		volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性。比如对volatile变量的单次读/写操作可以保证原子性的，如i基本类型变量的单次操作。但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。

- 读取i的值
- 对i加1
- 将i的值写回内存，volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。

**之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?**

​		因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。





**volatile是如何实现可见性的?  内存屏障。**

**volatile是如何实现有序性的?  happens-before等**

**说下volatile的应用场景**

## 5、synchronized、lock、volatile三者比较

## 6、final关键字

1. **所有的final修饰的字段都是编译期常量吗?**
2. **如何理解private所修饰的方法是隐式的final?**
3. **说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做?**
4. **final方法可以被重载吗? 可以**
5. **父类的final方法能不能够被子类重写? 不可以**
6. **说说final域重排序规则?**
7. **说说final的原理?**
8. **使用 final 的限制条件和局限性?**





