



# 多线程基础

## 一、线程、进程、多线程

### 1、进程

**进程**是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位

说起进程，就不得不说下程序，程序是指令和数据的集合，其本身没有任何运行的含义，是一个静态的概念。

### 2、线程

通常一个进程中可以包括若干个**线程**，当然一个进程中至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位

> 注意：很多多线程是模拟出来的，真正的多线程是指有多个cpu,即多核。只是模拟的时候切换时间非常快，造成了同时执行的错觉

![image-20220303192918832](F:\学习\java面试\并发\线程核心概念.png)

## 二、线程的创建

![image-20220303193138853](F:\学习\java面试\并发\img\线程创建方式.png)

### 1、Thread创建线程

- 用Thread类创建多线程

  - 自定义线程类继承**Thread类**
  - 重写**run()**方法，编写线程执行体
  - 创建线程对象，调用**start()**方法启动线程

  ```java
  package com.xianfeng.demo01;
  
  // 创建线程方式一：继承Thread类，重写()方法，调用start开启线程
  public class TestThread1 extends Thread{
      @Override
      public void run() {
          //run方法线程体
          for(int i = 0;i<200;i++){
              System.out.println("我在学习看代码--" + i);
          }
      }
  
  
      public static void main(String[] args) {
          //main线程
  
          //创建一个线程对象
          TestThread1 testThread1 = new TestThread1();
  
          //调用start()方法开启线程
          testThread1.start();
          for(int i = 0;i<20;i++){
              System.out.println("我在学习多线程--" + i);
          }
      }
  }
  ```

### 2、Runnable创建线程

- 通过Runnable接口创建多线程(**推荐**)

  - 定义MyRunnable类实现**Runnable接口**
  - 实现**run()**方法，编写线程执行体
  - 创建线程对象，调用**start()**方法启动线程

  ```java
  package com.xianfeng.demo01;
  
  //创建线程方式二：实现Runnable接口,重写run()方法，执行线程需要丢入runnable接口实现类，调用start()方法
  public class TestThread3 implements Runnable{
      @Override
      public void run() {
          //run方法线程体
          for(int i = 0;i<20;i++){
              System.out.println("我在学习看代码--" + i);
          }
      }
  
      public static void main(String[] args) {
          //main线程
  
          //创建RUnnable接口的实现类对象
          TestThread3 testThread3 = new TestThread3();
  
          //创建线程对象，通过线程对象来开启我们的线程，代理
          Thread thread = new Thread(testThread3);
          thread.start();
  
  
          for(int i = 0;i<200;i++){
              System.out.println("我在学习多线程--" + i);
          }
      }
  }
  
  ```

  ![image-20220303201556226](F:\学习\java面试\并发\img\RUnnable和Thread对比.png)

```java
package com.xianfeng.demo01;


//多个线程同时操作同一个对象
//买火车票的例子

//发现问题：多个线程操作同一个资源时数据紊乱，线程不安全
public class TestThread4 implements Runnable{

    private int tickNums = 10;

    @Override
    public void run() {
        while (true){

            if(tickNums < 0){
                break;
            }
            //模拟延时
            try {
                Thread.sleep(200);
            }catch (InterruptedException e){
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + "-->拿到了第"+ tickNums-- + "票");
        }
    }

    public static void main(String[] args) {
        TestThread4 testThread4 = new TestThread4();

        new Thread(testThread4, "小明").start();
        new Thread(testThread4, "黄牛").start();
        new Thread(testThread4, "老师").start();
    }
}
```

### 案例：龟兔赛跑

![image-20220303203700228](F:\学习\java面试\并发\img\龟兔赛跑.png)

```java
package com.xianfeng.demo01;

public class Race implements Runnable{
    private static String winner;

    @Override
    public void run() {
        for(int i =0;i<=100;i++){

            //模拟兔子休息
            if(Thread.currentThread().getName().equals("兔子") && i%10==0){
                try {
                    Thread.sleep(10);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
            //判断比赛是否结束
            boolean flag = gamwOver(i);

            //比赛阶数了,就停止程序
            if(flag){
                break;
            }
            System.out.println(Thread.currentThread().getName() + "--<跑了" + i + "步");
        }
    }

    //判断是否完成比赛
    private boolean gamwOver(int steps){
        //判断是否有胜利者
        if(winner!=null){
            return true;
        }else {
            if(steps >= 100){
                winner = Thread.currentThread().getName();
                System.out.println("winner is " + winner);
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        Race race = new Race();
        new Thread(race, "兔子").start();
        new Thread(race, "乌龟").start();
    }
}

```

### 3、Callable创建线程

![image-20220303205000455](F:\学习\java面试\并发\img\Callable创建线程.png)

## 三、静态代理模式

```java
package com.xianfeng.demo03;

//静态代理模式总结
//真实对象和代理对象都要实现同一个接口
//代理对象要代理真实角色

/**
 * 好处
 *      代理对象可以做很对真实对象做不了的事情
 *      真实对象专注做自己的事情
 */

public class staticProxy {
    public static void main(String[] args) {

        new Thread(()-> System.out.println("我爱你")).start();

        new WeddingCompany(new You("张老师"));


        WeddingCompany weddingCompany =new WeddingCompany(new You("秦老师"));
        weddingCompany.HappyMarry();
    }
}

interface Marry{
    void HappyMarry();
}

//真实角色
class You implements Marry{
    private String name;

    public You(String name){
        this.name = name;
    }

    @Override
    public void HappyMarry() {
        System.out.println(this.name + "要结婚了，超开心");
    }
}

//代理角色
class WeddingCompany implements Marry{
    private Marry target;


    //代理真实角色
    public WeddingCompany(Marry target){
        this.target = target;
    }

    @Override
    public void HappyMarry() {
        before();
        this.target.HappyMarry();
        after();
    }

    private void after() {
        System.out.println("结婚之后，收尾款");
    }

    private void before() {
        System.out.println("结婚之前，布置现场");
    }
}

```

## 四、Lamda表达式

### 1、Lamda概念

![image-20220303211440378](F:\学习\java面试\并发\img\Lamda表达式概念.png)

### 2、Lamda优点

![image-20220303211603055](F:\学习\java面试\并发\img\Lamda表达式优点.png)

### 3、函数式编程

![image-20220303211723303](F:\学习\java面试\并发\img\函数时接口.png)

```java
package com.xianfeng.demo03;

/*
推导lamda表达式
 */
public class Testlamda {
    //3.静态内部类
    static class Like2 implements ILike{
        @Override
        public void lambda() {
            System.out.println("I like lambda2");
        }
    }

    public static void main(String[] args) {
        ILike like = new Like();
        like.lambda();

        ILike like2 = new Like2();
        like2.lambda();

        //4.局部内部类
        class Like3 implements ILike{
            @Override
            public void lambda() {
                System.out.println("I like lambda3");
            }
        }
        ILike like3 = new Like3();
        like3.lambda();

        //5.匿名内部类, 没有类的名称，必须借助接口或者父类
        like = new ILike() {
            @Override
            public void lambda() {
                System.out.println("I like lambda4");
            }
        };

        like.lambda();

        //6.用lambda简化
        like = () ->{
            System.out.println("I like lambda5");
        };
        like.lambda();

    }
}

//1.定义一个函数时接口
interface ILike{
    void lambda();
}

//2.实现类
class Like implements ILike{
    @Override
    public void lambda() {
        System.out.println("I like lambda");
    }
}
```

```java
package com.xianfeng.demo03;

//lamda简化
public class TestLamda2 {
    static class Love implements ILove{
        @Override
        public void love(int a) {
            System.out.println("i love you2");
        }
    }


    public static void main(String[] args) {
        ILove love = new Love();
        love.love(2);

        class Love implements ILove{
            @Override
            public void love(int a) {
                System.out.println("i love you1");
            }
        }

        love = new ILove() {
            @Override
            public void love(int a) {
                System.out.println("i love you3");
            }
        };

        love = (int a)->{
            System.out.println("i love you4 " + a);
        };
        love.love(520);


        love = a ->{
            System.out.println("i love you5 " + a);
        };

        love.love(521);

        //只适合一行代码
        love = a -> System.out.println("i love you6 " + a);
        love.love(522);

    }
}


interface ILove{
    void love(int a);
}

class Love implements ILove{
    @Override
    public void love(int a) {
        System.out.println("i love you1");
    }
}
```

## 五、线程状态

### 1、线程状态

![image-20220303214754668](F:\学习\java面试\并发\img\线程状态.png)

![image-20220303214849762](F:\学习\java面试\并发\img\线程状态详图.png)

### 2、线程方法

![image-20220303215129101](F:\学习\java面试\并发\img\线程方法.png)

### 3、线程停止

![image-20220303215235931](C:\Users\Liu\AppData\Roaming\Typora\typora-user-images\image-20220303215235931.png)

