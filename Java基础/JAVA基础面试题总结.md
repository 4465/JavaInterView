---
typora-root-url: ./
---

# JAVA基础面试题总结

## 1、什么是封装

​		封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用**抽象数据类型**将**数据**和**基于数据的操作**封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。

使用封装有三大好处：

- 1、良好的封装能够减少耦合。
- 2、类内部的结构可以自由修改。
- 3、可以对成员进行更精确的控制。
- 4、隐藏信息，实现细节。

## 2、什么是继承

​		继承是**使用已存在的类的定义作为基础建立新类的技术**，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。继承所描述的是“is-a”的关系

同时在使用继承时需要记住三句话：

- 1、子类拥有父类非private的属性和方法。
- 2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
- 3、子类可以用自己的方式实现父类的方法。（重写）。

首先我们需要明确，继承存在如下缺陷：

- 1、父类变，子类就必须变。
- 2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。
- 3、继承是一种强耦合关系。

到底要不要使用继承：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。

## 3、什么是多态

​		多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。多态，**意味着一个对象有着多重特征**，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法。

Java实现多态有三个必要条件：继承、重写、向上转型。

- 继承：在多态中必须存在有继承关系的子类和父类。
- 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
- 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

## 4、Java中如何解决更好的解决四舍五入的问题

银行家涉入法：

- 舍去位的数值小于5时，直接舍去。
- 舍去位的数值大于5时，进位后舍去。
- 舍去位的数值等于5时
  - 若5后面还有其他非0数值，则进位后舍去。
  - 若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去

举例说明

- 11.556 = 11.56 ------六入
- 11.554 = 11.55 -----四舍
- 11.5551 = 11.56 -----五后有数进位
- 11.545 = 11.54 -----五后无数，若前位为偶数应舍去
- 11.555 = 11.56 -----五后无数，若前位为奇数应进位

## 5、面向对象编程的三大特性

​		封装、继承、多态

## 6、什么是抽象类

​		在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。

在使用抽象类时需要注意几点：

- 1、**抽象类不能被实例化**，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。

- 2、抽象方法**必须**由子类来进行**重写**。

  > 每个抽象方法都需要被重写，不能存在未被重写的抽象方法

- 3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。

- 4、**抽象类中可以包含具体的方法**，当然也可以不包含抽象方法。

  > 抽象方法和具体方法的区别在于抽象方法不能有方法体

- 5、子类中的抽象方法不能与父类的抽象方法同名。

- 6、abstract不能与final并列修饰同一个类。

- 7、abstract 不能与private、static、final或native并列修饰同一个方法。、

## 7、什么是接口

​		在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。

如果一个抽象类没有字段，所有方法全部都是抽象方法。

在使用接口过程中需要注意如下几个问题：

- 1、Interface的方所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！
- 2、接口可以包含变量；变量被隐式指定为public static final；
- 3、接口中不存在实现的方法。
- 4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。
- 5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。

## 8、抽象类和接口的相同点和不同点

- 相同点
  - 都不能被实例化 
  - 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。

- 不同点：
  - 1、接口所有的方法都是抽象的，抽象类可以有抽象方法和非抽象方法。
  - 2、类可以实现很多接口（接口多继承），但是只能实现一个抽象类（抽象类单继承）
  - 3、类实现接口，接口中的抽象方法必须被实现。类继承抽象类可以不实现抽象类的所有方法（单需要实现所有的抽象方法，具体方法直接继承），但是它本身需要声明为抽象类。
  - 4、接口声明的变量必须是final类型的，抽象类可以包括final和非final类型的变量（值可以在子类中重新定义和改变）。
  - 5、接口中的函数都是public的，但是抽象类可以是private、protected，public
  - 6、接口强调特定功能的实现，而抽象类强调所属关系。

## 9、什么时候使用接口什么时候使用抽象类

​	大部分的情况下推荐使用接口，因为接口可以多实现，而抽象类只能单继承，单一个类有自己的父类时，只能选用实现接口的方式。

## 10、说一说关键字static

在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，**注意：java中不说全局变量**。在Java中static表示“**全局**”或者“**静态**”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块和类。

> ### 为什么要用static关键字？ 
>
> 通常来说，用new创建类的对象时，数据存储空间才被分配，方法才供外界调用。但有时我们只想为特定域分配单一存储空间，不考虑要创建多少对象或者说根本就不创建任何对象，再就是我们想在没有创建对象的情况下也想调用方法。在这两种情况下，static关键字，满足了我们的需求。
>
> ### ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？
>
> “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
>
> Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
>
> ### 是否可以在static环境中访问非static变量？
>
> static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。
>
> ###  static静态方法能不能引用非静态资源？
>
> 不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。
>
> ### static静态方法里面能不能引用静态资源？
>
> 可以，因为都是类初始化的时候加载的，大家相互都认识。
>
> ### 非静态方法里面能不能引用静态资源？
>
> 可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。

1. static修饰变量

   static修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：

   静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。

   但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。

   所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。

2. static修饰方法

   static修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。

   Static方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。

3. static修饰类

   **如果一个类要被声明为static的，只有一种情况，就是静态内部类。**

4. static修饰代码块

   被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行（只执行一次,并优先于主函数），具体说，**静态代码块是由类调用**的。类调用时，先执行静态代码块，然后才执行主函数的,**静态代码块其实就是给类初始化的**。

   

   ![image-20220308132602575](F:\学习\java面试\Java基础\img\静态代码块.png)

5. static在内存中的实现

   Java把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置(方法区)开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。

![](/img/static缺陷.png)

## 11、内部类是什么?有什么好处？

内部类是在类内容定义的类，有成员内部类、局部内部类、匿名内部类和静态内部类。内部类能够非常好的解决多继承的问题。使用内部类还能够为我们带来如下特性：

- 1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
- 2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
- 3、创建内部类对象的时刻并不依赖于外围类对象的创建。
- 4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
- 5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。

> ### 成员内部类
>
> - 第一：成员内部类中不能存在任何static的变量和方法；
> - 第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。
>
> ### 局部内部类
>
> 嵌套在方法和作用域内的
>
> ### 匿名内部类
>
> 在做Swing编程中，我们经常使用这种方式来绑定事件
>
> - 1、** 匿名内部类是没有访问修饰符的。
> - 2、** new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。
> - 3、** 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。
> - 4、** 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。
>
> ### 静态内部类
>
> 静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：
>
> - 1、** 它的创建是不需要依赖于外围类的。
> - 2、** 它不能使用任何外围类的非static成员变量和方法。

## 12、JAVA允许多继承吗？

严格来说，JAVA语法是不支持多继承的，但是在JAVA中可以通过接口和内部类的方式实现多继承

## 13、匿名内部类

在使用匿名内部类的过程中，我们需要注意如下几点：

- 1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。
- 2、匿名内部类中是不能定义构造函数的。
- 3、匿名内部类中不能存在任何的静态成员变量和静态方法。
- 4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。
- 5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。

> ### 匿名内部类使用的形参为何要为final
>
> 首先在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用，但实际并不是这样的
>
> 内部类利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。那么为什么是final呢？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。（保持值传递）
>
> ### 匿名内部类初始化
>
> 匿名内部类没有构造器，使用构造代码块来初始化

## 14、强制类型转换

在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。

## 15、代码块

1. 普通代码块

2. 静态代码块

3. 同步代码块

4. 构造代码块

   代码块是没有独立运行的能力，他必须要有一个可以承载的载体，编译器会将构造代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：

   ```java
    public class Test {
              /**
               * 构造代码
               */
              {
                  System.out.println("执行构造代码块...");
              }
           
              /**
               * 无参构造函数
               */
              public Test(){
                  System.out.println("执行无参构造函数...");
              }
           
              /**
               * 有参构造函数
               * @param id  id
               */
              public Test(String id){
                  System.out.println("执行有参构造函数...");
              }
           }
   ```

   等价：

   ```java
     
   public class Test {
              /**
               * 无参构造函数
               */
              public Test(){
                  System.out.println("执行构造代码块...");
                  System.out.println("执行无参构造函数...");
              }
           
              /**
               * 有参构造函数
               * @param id  id
               */
              public Test(String id){
                  System.out.println("执行构造代码块...");
                  System.out.println("执行有参构造函数...");
              }
           
           }
   ```

   ```java
     public static void main(String[] args) {
                  new Test();
                  System.out.println("----------------");
                  new Test("1");
              }
           ------------
           Output:
           执行构造代码块...
           执行无参构造函数...
           ----------------
           执行构造代码块...
           执行有参构造函数...
   ```

   **在new一个对象的时候总是先执行构造代码，再执行构造函数**，但是有一点需要**注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的**。正是由于构造代码块有这几个特性，所以它常用于如下场景：

   **1、 初始化实例变量**

   如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。

   **2、 初始化实例环境**

   一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。

   > ### 静态代码块、构造代码块、构造函数执行顺序
   >
   > - 1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。
   >
   > - 2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。
   >
   > - 3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。
   >
   > - ```java
   >   public class Test {
   >           /**
   >               * 静态代码块
   >            */
   >           static{
   >               System.out.println("执行静态代码块...");
   >           }
   >          
   >           /**
   >               * 构造代码块
   >            */
   >           {
   >               System.out.println("执行构造代码块...");
   >           }
   >          
   >           /**
   >               * 无参构造函数
   >            */
   >           public Test(){
   >               System.out.println("执行无参构造函数...");
   >           }
   >          
   >           /**
   >               * 有参构造函数
   >               * @param id
   >            */
   >           public Test(String id){
   >               System.out.println("执行有参构造函数...");
   >           }
   >          
   >           public static void main(String[] args) {
   >               System.out.println("----------------------");
   >               new Test();
   >               System.out.println("----------------------");
   >               new Test("1");
   >           }
   >        }
   >        -----------
   >        Output:
   >        执行静态代码块...
   >        ----------------------
   >        执行构造代码块...
   >        执行无参构造函数...
   >        ----------------------
   >        执行构造代码块...
   >        执行有参构造函数...
   >          
   >   ```
   >  ```
   > 
   > 
   >  ```

## 16、final关键字

final是java的关键字，表示这部分是无法修改的。 使用到final的有三种情况：数据、方法、类 。

1. final修饰变量

   final主要应用与以下两个地方：

   - 1、编译期常量，永远不可改变。===>只能使用基本类型

   - 2、运行期初始化时，我们希望它不会被改变。    ===>既可以是基本数据类型，也可以是引用数据类型

     > 基本数据类型不可变的是其内容，而引用数据类型不可变的是其引用，引用所指定的对象内容是可变的。 
     >
     > ```java
     >  public class Person {
     >             private String name;
     >         
     >             Person(String name){
     >                 this.name = name;
     >             }
     >         
     >             public String getName() {
     >                 return name;
     >             }
     >         
     >             public void setName(String name) {
     >                 this.name = name;
     >             }
     >         }
     >         
     >         public class FinalTest {
     >             private final String final_01 = "chenssy";    //编译期常量，必须要进行初始化，且不可更改
     >             private final String final_02;                //构造器常量，在实例化一个对象时被初始化
     >         
     >             private static Random random = new Random();
     >             private final int final_03 = random.nextInt(50);    //使用随机数来进行初始化
     >         
     >             //引用
     >             public final Person final_04 = new Person("chen_ssy");    //final指向引用数据类型
     >         
     >             FinalTest(String final_02){
     >                 this.final_02 = final_02;
     >             }
     >         
     >             public String toString(){
     >                 return "final_01 = " + final_01 +"   final_02 = " + final_02 + "   final_03 = " + final_03 +
     >                        "   final_04 = " + final_04.getName();
     >             }
     >         
     >             public static void main(String[] args) {
     >                 System.out.println("------------第一次创建对象------------");
     >                 FinalTest final1 = new FinalTest("cm");
     >                 System.out.println(final1);
     >                 System.out.println("------------第二次创建对象------------");
     >                 FinalTest final2 = new FinalTest("zj");
     >                 System.out.println(final2);
     >                 System.out.println("------------修改引用对象--------------");
     >                 final2.final_04.setName("chenssy");
     >                 System.out.println(final2);
     >             }
     >         }
     >         
     >         ------------------
     >         Output:
     >         ------------第一次创建对象------------
     >         final_01 = chenssy   final_02 = cm   final_03 = 34   final_04 = chen_ssy
     >         ------------第二次创建对象------------
     >         final_01 = chenssy   final_02 = zj   final_03 = 46   final_04 = chen_ssy
     >         ------------修改引用对象--------------
     >         final_01 = chenssy   final_02 = zj   final_03 = 46   final_04 = chenssy
     > ```
     >
     > 

2. fina修饰方法

   - 方法锁定

      所有被final标注的方法都是不能被继承、更改的 。方法锁定， 防止任何子类来对它的修改 

   - 效率

3. final修饰类

   表明该类是最终类，不能被继承

   > 对于final修饰的类来说，它的成员变量可以为final，也可以为非final。如果定义为final，那么final数据的规则同样适合它。而它的方法则会自动的加上final，因为final类是无法被继承，所以这个是默认的。 

4. final修饰参数

   参数不可改变

   

## 17、equals()与==的区别

![1646757480244](/img/equals.png)

## 18、异常处理

![image-20220309094124884](/img/异常处理.png)

异常：

1. Error(错误)

   例子：OutOfMemoryError、ThreadDeath等，出现这种情况你唯一能做的就是听之任之，交由JVM来处理，不过JVM在大多数情况下会选择终止线程。

2. Exception(程序可以处理的异常)

   - CheckedException（受捡异常）：CheckException发生在编译阶段，必须要使用try…catch（或者throws）否则编译不通过
   - UncheckedException（不受检异常）：UncheckedException发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的，难以排查

对于可恢复的条件使用被检查的异常（CheckedException），对于程序错误（言外之意不可恢复，大错已经酿成）使用运行时异常（RuntimeException）。

 **不论程序是否发生异常，finally代码块总是会执行。所以finally一般用来关闭资源。**

**若程序中显示的声明了某个异常，则抛出异常时不会显示出处，若程序中没有显示的声明某个异常，当抛出异常时，系统会显示异常的出处。**

> ### 自定义异常
>
> Java自定义异常的使用要经历如下四个步骤：
>
> - 1、定义一个类继承Throwable或其子类。
> - 2、添加构造方法(当然也可以不用添加，使用默认构造方法)。
> - 3、在某个方法类抛出该异常。
> - 4、捕捉该异常。
>
> ### throw和throws区别
>
> 1、throw生成异常对象，抛出一个异常类的对象；throws是异常处理方式，用来声明抛出异常；
>
> 2、throw在方法体内；throws在方法声明处。

## 19、String

​		String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。

> ### ””、null、new String()三者的区别
>
> - null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他
> - ””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的
>
> ### **String s = new String(“abc)****创建几个对象
>
> 2个，一个堆空间中new的结构，另一个是char[]对应常量池中的数据abc。

​		在字符串中存在一个非常特殊的地方，那就是**字符串池**。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。

![image-20220309100605362](/img/字符串的使用.png)

> ### **String**、StringBuffer、StringBuilder异同
>
> 1、定义区别：
>
> String：是不可变字符序列，对象一旦生成，就不可更改，对String的改变会引发新的String对象的生成。
>
> StringBuffer：可变字符序列，线程安全，但是效率较低。
>
> StringBuilder：可变字符序列，线程不安全，效率高，JDK1.5新增。
>
> 2、底层区别：
>
> String：底层用char[]存储。
>
> StringBuffer、StringBuilder：底层用char[]存储，new StringBuffer会创建一个长度为16的char数组，当长度不够需要扩容的时候，默认扩容为原来的2倍+2，同时copy原有数组。
>
> ![image-20220309101657168](/img/三个String比较.png)

> ### 字符串拼接方式
>
> append()速度最快，concat()次之，+最慢
>
> - +
> - concat
> - append

