# 1.说说对设计模式的理解

​		设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

​		设计模式来源于 Christopher Alexander（克里斯托弗.亚历山大） 的经典著作 《建筑的永恒之道》 ，在这本书中他给出了关于模式的定义

>  **每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。** 概括起来就是一句话： 模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案 

​		软件工程后来将设计模式引入到软件工程领域。

# 2.设计模式的分类

- 创建型模式，共五种：**工厂方法模式、抽象工厂模式**、**单例模式**、建造者模式、**原型模式。**

- 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

- 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172acfe20b2d2d~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp">

# 3.设计模式的六大原则

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172acff10be430~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp">

| 设计原则名称 | 定 义                                            | 使用频率 |
| ------------ | ------------------------------------------------ | -------- |
| 单一职责原则 | 一个类只负责一个功能领域中的相应职责             | ★★★★☆    |
| 开闭原则     | 软件实体应对扩展开放，而对修改关闭               | ★★★★★    |
| 里氏代换原则 | 所有引用基类对象的地方能够透明地使用其子类的对象 | ★★★★★    |
| 依赖倒转原则 | 抽象不应该依赖于细节，细节应该依赖于抽象         | ★★★★★    |
| 接口隔离原则 | 使用多个专门的接口，而不使用单一的总接口         | ★★☆☆☆    |
| 合成复用原则 | 尽量使用对象组合，而不是继承来达到复用的目的     | ★★★★☆    |
| 迪米特法则   | 一个软件实体应当尽可能少地与其他实体发生相互作用 | ★★★☆☆    |

> ## 1.开闭原则
>
> 原则思想： 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 
>
> 描述： 任何软件或者系统都需要面临一个很重要的问题，当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。
>
> 有点：便于系统代码的更新和扩展，降低软件或系统的维护成本
>
> ## 2. 单一职责原则
>
> 原则思想： 一个方法只负责一件事情。 
>
> 描述： 单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。  单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小 。
>
> 优点： 降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。 
>
> ## 3.里氏代换原则
>
> 原则思想： 使用的基类可以在任何地方使用继承的子类，完美的替换基类。 
>
> 描述：  在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。   
>
> 优点： 增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。 
>
> ## 4.依赖倒转原则
>
> 原则思想：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 
>
> 描述： 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情 
>
> 优点： 对接口编程，依赖于抽象而不依赖于具体。 
>
> ## 5.接口隔离原则
>
> 原则思想：   使用多个隔离的接口，比使用单个接口要好。 降低类之间的耦合度
>
> 描述：当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。**每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。** 
>
> 优点：降低类的耦合度
>
> ## 6.迪米特法则
>
> 原则思想： 一 一个软件实体应当尽可能少地与其他实体发生相互作用。 
>
> 描述： 大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。 
>
> 优点： 低耦合，高内聚 。

# 4.单例模式

## 1.概念

​		保证一个类只有一个实例，并且提供一个访问该全局访问点。

## 2.哪些地方用到了单例模式

1. 网站的计数器，一般也是采用单例模式实现，否则难以同步。
2. 应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。
3. 多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控制
4. Windows的（任务管理器）就是很典型的单例模式，他不能打开俩个
5. windows的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例。

## 3.单例的优缺点

### 1.优点

1. 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例
2. 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。
3. 提供了对唯一实例的受控访问。
4. 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。
5. 允许可变数目的实例。
6. 避免对共享资源的多重占用。

### 2.缺点

1. 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。
2. 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。
3. 单例类的职责过重，在一定程度上违背了“单一职责原则”。
4. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。

## 4.单例模式使用注意事项

1. 使用时不能用反射模式创建单例，否则会实例化一个新的对象
2. 使用懒单例模式时注意线程安全问题
3. 饿单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承（如登记式模式）

## 5.单例防止反射漏洞攻击

```java
private static boolean flag = false;

private Singleton() {

	if (flag == false) {
		flag = !flag;
	} else {
		throw new RuntimeException("单例模式被侵犯！");
	}
}

public static void main(String[] args) {

}

```

## 6.如何选择单例创建模式

​		如果不需要延迟加载单例，可以使用枚举或者饿汉式，相对来说枚举性好于饿汉式。 如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒韩式。 最好使用饿汉式

## 7.单例创建方式

**（主要使用懒汉和懒汉式）**

1. 饿汉式:类初始化时,会立即加载该对象，线程天生安全,调用效率高。
2. 懒汉式: 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。
3. 静态内部方式:结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。
4. 枚举单例: 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。
5. 双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)

### 1.饿汉式

1. 饿汉式:类初始化时,会立即加载该对象，线程天生安全,调用效率高。

   ```java
   package com.lijie;
   
   //饿汉式
   public class Demo1 {
   
       // 类初始化时,会立即加载该对象，线程安全,调用效率高
       private static Demo1 demo1 = new Demo1();
   
       private Demo1() {
           System.out.println("私有Demo1构造参数初始化");
       }
   
       public static Demo1 getInstance() {
           return demo1;
       }
   
       public static void main(String[] args) {
           Demo1 s1 = Demo1.getInstance();
           Demo1 s2 = Demo1.getInstance();
           System.out.println(s1 == s2);
       }
   }
   
   
   
   ```

### 2.懒汉式

1. 懒汉式: 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。

   ```java
   package com.lijie;
   
   //懒汉式
   public class Demo2 {
   
       //类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。
       private static Demo2 demo2;
   
       private Demo2() {
           System.out.println("私有Demo2构造参数初始化");
       }
   
       public synchronized static Demo2 getInstance() {
           if (demo2 == null) {
               demo2 = new Demo2();
           }
           return demo2;
       }
   
       public static void main(String[] args) {
           Demo2 s1 = Demo2.getInstance();
           Demo2 s2 = Demo2.getInstance();
           System.out.println(s1 == s2);
       }
   }
   
   
   
   ```

### 3.静态内部类

1. 静态内部方式:结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的

   ```JAVA
   package com.lijie;
   
   // 静态内部类方式
   public class Demo3 {
   
       private Demo3() {
           System.out.println("私有Demo3构造参数初始化");
       }
   
       public static class SingletonClassInstance {
           private static final Demo3 DEMO_3 = new Demo3();
       }
   
       // 方法没有同步
       public static Demo3 getInstance() {
           return SingletonClassInstance.DEMO_3;
       }
   
       public static void main(String[] args) {
           Demo3 s1 = Demo3.getInstance();
           Demo3 s2 = Demo3.getInstance();
           System.out.println(s1 == s2);
       }
   }
   
   
   ```

   